{"ast":null,"code":"/* eslint-disable */\nvar BigInteger = require('./jsbn');\nvar SecureRandom = require('./rng');\nvar rsa = function () {\n  'use strict';\n\n  // convert a (hex) string to a bignum object\n  function parseBigInt(str, r) {\n    return new BigInteger(str, r);\n  }\n  /*\r\n  function linebrk(s,n) {\r\n    var ret = \"\";\r\n    var i = 0;\r\n    while(i + n < s.length) {\r\n      ret += s.substring(i,i+n) + \"\\n\";\r\n      i += n;\r\n    }\r\n    return ret + s.substring(i,s.length);\r\n  }\r\n    function byte2Hex(b) {\r\n    if(b < 0x10)\r\n      return \"0\" + b.toString(16);\r\n    else\r\n      return b.toString(16);\r\n  }\r\n  */\n\n  // PKCS#1 (type 2, random) pad input string s to n bytes, and return a bigint\n  function pkcs1pad2(s, n) {\n    if (n < s.length + 11) {\n      // TODO: fix for utf-8\n      alert('Message too long for RSA');\n      return null;\n    }\n    var ba = new Array();\n    var i = s.length - 1;\n    while (i >= 0 && n > 0) {\n      var c = s.charCodeAt(i--);\n      if (c < 128) {\n        // encode using utf-8\n        ba[--n] = c;\n      } else if (c > 127 && c < 2048) {\n        ba[--n] = c & 63 | 128;\n        ba[--n] = c >> 6 | 192;\n      } else {\n        ba[--n] = c & 63 | 128;\n        ba[--n] = c >> 6 & 63 | 128;\n        ba[--n] = c >> 12 | 224;\n      }\n    }\n    ba[--n] = 0;\n    var rng = new SecureRandom();\n    var x = new Array();\n    while (n > 2) {\n      // random non-zero pad\n      x[0] = 0;\n      while (x[0] == 0) rng.nextBytes(x);\n      ba[--n] = x[0];\n    }\n    ba[--n] = 2;\n    ba[--n] = 0;\n    return new BigInteger(ba);\n  }\n\n  // \"empty\" RSA key constructor\n  function RSAKey() {\n    this.n = null;\n    this.e = 0;\n    this.d = null;\n    this.p = null;\n    this.q = null;\n    this.dmp1 = null;\n    this.dmq1 = null;\n    this.coeff = null;\n  }\n\n  // Set the public key fields N and e from hex strings\n  function RSASetPublic(N, E) {\n    if (N != null && E != null && N.length > 0 && E.length > 0) {\n      this.n = parseBigInt(N, 16);\n      this.e = parseInt(E, 16);\n    } else {\n      console.log('Invalid RSA public key');\n    }\n  }\n\n  // Perform raw public operation on \"x\": return x^e (mod n)\n  function RSADoPublic(x) {\n    return x.constructor === BigInteger ? x.modPowInt(this.e, this.n) : '';\n  }\n\n  // Return the PKCS#1 RSA encryption of \"text\" as an even-length hex string\n  function RSAEncrypt(text) {\n    var m = pkcs1pad2(text, this.n.bitLength() + 7 >> 3);\n    if (m == null) return null;\n    var c = this.doPublic(m);\n    if (c == null) return null;\n    var h = c.toString(16);\n    if ((h.length & 1) == 0) return h;else return '0' + h;\n  }\n\n  // protected\n  RSAKey.prototype.doPublic = RSADoPublic;\n\n  // public\n  RSAKey.prototype.setPublic = RSASetPublic;\n  RSAKey.prototype.encrypt = RSAEncrypt;\n  return RSAKey;\n}();\nconsole.log('rsa', rsa);\nif (typeof module === 'object' && module.exports) {\n  module.exports = rsa;\n}","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}
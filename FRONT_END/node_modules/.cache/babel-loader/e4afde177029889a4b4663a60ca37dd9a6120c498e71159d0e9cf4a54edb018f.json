{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.webstomp = factory();\n})(this, function () {\n  'use strict';\n\n  var classCallCheck = function (instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  };\n  var createClass = function () {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n    return function (Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) defineProperties(Constructor, staticProps);\n      return Constructor;\n    };\n  }();\n  var slicedToArray = function () {\n    function sliceIterator(arr, i) {\n      var _arr = [];\n      var _n = true;\n      var _d = false;\n      var _e = undefined;\n      try {\n        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n          _arr.push(_s.value);\n          if (i && _arr.length === i) break;\n        }\n      } catch (err) {\n        _d = true;\n        _e = err;\n      } finally {\n        try {\n          if (!_n && _i[\"return\"]) _i[\"return\"]();\n        } finally {\n          if (_d) throw _e;\n        }\n      }\n      return _arr;\n    }\n    return function (arr, i) {\n      if (Array.isArray(arr)) {\n        return arr;\n      } else if (Symbol.iterator in Object(arr)) {\n        return sliceIterator(arr, i);\n      } else {\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n      }\n    };\n  }();\n  var toConsumableArray = function (arr) {\n    if (Array.isArray(arr)) {\n      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n      return arr2;\n    } else {\n      return Array.from(arr);\n    }\n  };\n  var VERSIONS = {\n    V1_0: '1.0',\n    V1_1: '1.1',\n    V1_2: '1.2',\n    // Versions of STOMP specifications supported\n    supportedVersions: function supportedVersions() {\n      return '1.2,1.1,1.0';\n    },\n    supportedProtocols: function supportedProtocols() {\n      return ['v10.stomp', 'v11.stomp', 'v12.stomp'];\n    }\n  };\n  var PROTOCOLS_VERSIONS = {\n    'v10.stomp': VERSIONS.V1_0,\n    'v11.stomp': VERSIONS.V1_1,\n    'v12.stomp': VERSIONS.V1_2\n  };\n  function getSupportedVersion(protocol, debug) {\n    var knownVersion = PROTOCOLS_VERSIONS[protocol];\n    if (!knownVersion && debug) {\n      debug('DEPRECATED: ' + protocol + ' is not a recognized STOMP version. In next major client version, this will close the connection.');\n    }\n    // 2nd temporary fallback if the protocol\n    // does not match a supported STOMP version\n    // This fallback will be removed in next major version\n    return knownVersion || VERSIONS.V1_2;\n  }\n\n  // Define constants for bytes used throughout the code.\n  var BYTES = {\n    // LINEFEED byte (octet 10)\n    LF: '\\x0A',\n    // NULL byte (octet 0)\n    NULL: '\\x00'\n  };\n\n  // utility function to trim any whitespace before and after a string\n  var trim = function trim(str) {\n    return str.replace(/^\\s+|\\s+$/g, '');\n  };\n\n  // from https://coolaj86.com/articles/unicode-string-to-a-utf-8-typed-array-buffer-in-javascript/\n  function unicodeStringToTypedArray(s) {\n    var escstr = encodeURIComponent(s);\n    var binstr = escstr.replace(/%([0-9A-F]{2})/g, function (match, p1) {\n      return String.fromCharCode('0x' + p1);\n    });\n    var arr = Array.prototype.map.call(binstr, function (c) {\n      return c.charCodeAt(0);\n    });\n    return new Uint8Array(arr);\n  }\n\n  // from https://coolaj86.com/articles/unicode-string-to-a-utf-8-typed-array-buffer-in-javascript/\n  function typedArrayToUnicodeString(ua) {\n    var binstr = String.fromCharCode.apply(String, toConsumableArray(ua));\n    var escstr = binstr.replace(/(.)/g, function (m, p) {\n      var code = p.charCodeAt(0).toString(16).toUpperCase();\n      if (code.length < 2) {\n        code = '0' + code;\n      }\n      return '%' + code;\n    });\n    return decodeURIComponent(escstr);\n  }\n\n  // Compute the size of a UTF-8 string by counting its number of bytes\n  // (and not the number of characters composing the string)\n  function sizeOfUTF8(s) {\n    if (!s) return 0;\n    return encodeURIComponent(s).match(/%..|./g).length;\n  }\n  function createId() {\n    var ts = new Date().getTime();\n    var rand = Math.floor(Math.random() * 1000);\n    return ts + '-' + rand;\n  }\n\n  // [STOMP Frame](http://stomp.github.com/stomp-specification-1.1.html#STOMP_Frames) Class\n\n  var Frame = function () {\n    // Frame constructor\n    function Frame(command) {\n      var headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var body = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      classCallCheck(this, Frame);\n      this.command = command;\n      this.headers = headers;\n      this.body = body;\n    }\n\n    // Provides a textual representation of the frame\n    // suitable to be sent to the server\n\n    createClass(Frame, [{\n      key: 'toString',\n      value: function toString() {\n        var _this = this;\n        var lines = [this.command],\n          skipContentLength = this.headers['content-length'] === false;\n        if (skipContentLength) delete this.headers['content-length'];\n        Object.keys(this.headers).forEach(function (name) {\n          var value = _this.headers[name];\n          lines.push(name + ':' + value);\n        });\n        if (this.body && !skipContentLength) {\n          lines.push('content-length:' + sizeOfUTF8(this.body));\n        }\n        lines.push(BYTES.LF + this.body);\n        return lines.join(BYTES.LF);\n      }\n\n      // Unmarshall a single STOMP frame from a `data` string\n    }], [{\n      key: 'unmarshallSingle',\n      value: function unmarshallSingle(data) {\n        // search for 2 consecutives LF byte to split the command\n        // and headers from the body\n        var divider = data.search(new RegExp(BYTES.LF + BYTES.LF)),\n          headerLines = data.substring(0, divider).split(BYTES.LF),\n          command = headerLines.shift(),\n          headers = {},\n          body = '',\n          // skip the 2 LF bytes that divides the headers from the body\n          bodyIndex = divider + 2;\n\n        // Parse headers in reverse order so that for repeated headers, the 1st\n        // value is used\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n        try {\n          for (var _iterator = headerLines.reverse()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var line = _step.value;\n            var idx = line.indexOf(':');\n            headers[trim(line.substring(0, idx))] = trim(line.substring(idx + 1));\n          }\n          // Parse body\n          // check for content-length or topping at the first NULL byte found.\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n        if (headers['content-length']) {\n          var len = parseInt(headers['content-length'], 10);\n          body = ('' + data).substring(bodyIndex, bodyIndex + len);\n        } else {\n          var chr = null;\n          for (var i = bodyIndex; i < data.length; i++) {\n            chr = data.charAt(i);\n            if (chr === BYTES.NULL) break;\n            body += chr;\n          }\n        }\n        return new Frame(command, headers, body);\n      }\n\n      // Split the data before unmarshalling every single STOMP frame.\n      // Web socket servers can send multiple frames in a single websocket message.\n      // If the message size exceeds the websocket message size, then a single\n      // frame can be fragmented across multiple messages.\n      //\n      // `datas` is a string.\n      //\n      // returns an *array* of Frame objects\n    }, {\n      key: 'unmarshall',\n      value: function unmarshall(datas) {\n        // split and unmarshall *multiple STOMP frames* contained in a *single WebSocket frame*.\n        // The data is split when a NULL byte (followed by zero or many LF bytes) is found\n        var frames = datas.split(new RegExp(BYTES.NULL + BYTES.LF + '*')),\n          firstFrames = frames.slice(0, -1),\n          lastFrame = frames.slice(-1)[0],\n          r = {\n            frames: firstFrames.map(function (f) {\n              return Frame.unmarshallSingle(f);\n            }),\n            partial: ''\n          };\n\n        // If this contains a final full message or just a acknowledgement of a PING\n        // without any other content, process this frame, otherwise return the\n        // contents of the buffer to the caller.\n        if (lastFrame === BYTES.LF || lastFrame.search(RegExp(BYTES.NULL + BYTES.LF + '*$')) !== -1) {\n          r.frames.push(Frame.unmarshallSingle(lastFrame));\n        } else {\n          r.partial = lastFrame;\n        }\n        return r;\n      }\n\n      // Marshall a Stomp frame\n    }, {\n      key: 'marshall',\n      value: function marshall(command, headers, body) {\n        var frame = new Frame(command, headers, body);\n        return frame.toString() + BYTES.NULL;\n      }\n    }]);\n    return Frame;\n  }();\n\n  // STOMP Client Class\n  //\n  // All STOMP protocol is exposed as methods of this class (`connect()`,\n  // `send()`, etc.)\n\n  var Client = function () {\n    function Client(ws) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      classCallCheck(this, Client);\n\n      // cannot have default options object + destructuring in the same time in method signature\n      var _options$binary = options.binary,\n        binary = _options$binary === undefined ? false : _options$binary,\n        _options$heartbeat = options.heartbeat,\n        heartbeat = _options$heartbeat === undefined ? {\n          outgoing: 10000,\n          incoming: 10000\n        } : _options$heartbeat,\n        _options$debug = options.debug,\n        debug = _options$debug === undefined ? true : _options$debug,\n        _options$protocols = options.protocols,\n        protocols = _options$protocols === undefined ? [] : _options$protocols;\n      this.ws = ws;\n      this.ws.binaryType = 'arraybuffer';\n      this.isBinary = !!binary;\n      this.hasDebug = !!debug;\n      this.connected = false;\n      // Heartbeat properties of the client\n      // outgoing: send heartbeat every 10s by default (value is in ms)\n      // incoming: expect to receive server heartbeat at least every 10s by default\n      // falsy value means no heartbeat hence 0,0\n      this.heartbeat = heartbeat || {\n        outgoing: 0,\n        incoming: 0\n      };\n      // maximum *WebSocket* frame size sent by the client. If the STOMP frame\n      // is bigger than this value, the STOMP frame will be sent using multiple\n      // WebSocket frames (default is 16KiB)\n      this.maxWebSocketFrameSize = 16 * 1024;\n      // subscription callbacks indexed by subscriber's ID\n      this.subscriptions = {};\n      this.partialData = '';\n      this.protocols = protocols;\n    }\n\n    // //// Debugging\n    //\n    // By default, debug messages are logged in the window's console if it is defined.\n    // This method is called for every actual transmission of the STOMP frames over the\n    // WebSocket.\n    //\n    // It is possible to set a `debug(message, data)` method\n    // on a client instance to handle differently the debug messages:\n    //\n    //     client.debug = function(str) {\n    //         // append the debug log to a #debug div\n    //         $(\"#debug\").append(str + \"\\n\");\n    //     };\n\n    createClass(Client, [{\n      key: 'debug',\n      value: function debug() {\n        var _console;\n        if (this.hasDebug) (_console = console).log.apply(_console, arguments);\n      }\n\n      // [CONNECT Frame](http://stomp.github.com/stomp-specification-1.1.html#CONNECT_or_STOMP_Frame)\n      //\n      // The `connect` method accepts different number of arguments and types:\n      //\n      // * `connect(headers, connectCallback)`\n      // * `connect(headers, connectCallback, errorCallback)`\n      // * `connect(login, passcode, connectCallback)`\n      // * `connect(login, passcode, connectCallback, errorCallback)`\n      // * `connect(login, passcode, connectCallback, errorCallback, host)`\n      //\n      // The errorCallback is optional and the 2 first forms allow to pass other\n      // headers in addition to `client`, `passcode` and `host`.\n    }, {\n      key: 'connect',\n      value: function connect() {\n        var _this = this;\n        var _parseConnect2 = this._parseConnect.apply(this, arguments),\n          _parseConnect3 = slicedToArray(_parseConnect2, 3),\n          headers = _parseConnect3[0],\n          connectCallback = _parseConnect3[1],\n          errorCallback = _parseConnect3[2];\n        this.connectCallback = connectCallback;\n        this.debug('Opening Web Socket...');\n        this.ws.onmessage = function (evt) {\n          var data = evt.data;\n          if (evt.data instanceof ArrayBuffer) {\n            data = typedArrayToUnicodeString(new Uint8Array(evt.data));\n          }\n          _this.serverActivity = Date.now();\n          // heartbeat\n          if (data === BYTES.LF) {\n            _this.debug('<<< PONG');\n            return;\n          }\n          _this.debug('<<< ' + data);\n          // Handle STOMP frames received from the server\n          // The unmarshall function returns the frames parsed and any remaining\n          // data from partial frames.\n          var unmarshalledData = Frame.unmarshall(_this.partialData + data);\n          _this.partialData = unmarshalledData.partial;\n          unmarshalledData.frames.forEach(function (frame) {\n            switch (frame.command) {\n              // [CONNECTED Frame](http://stomp.github.com/stomp-specification-1.1.html#CONNECTED_Frame)\n              case 'CONNECTED':\n                _this.debug('connected to server ' + frame.headers.server);\n                _this.connected = true;\n                _this.version = frame.headers.version;\n                _this._setupHeartbeat(frame.headers);\n                if (connectCallback) connectCallback(frame);\n                break;\n              // [MESSAGE Frame](http://stomp.github.com/stomp-specification-1.1.html#MESSAGE)\n              case 'MESSAGE':\n                // the `onreceive` callback is registered when the client calls\n                // `subscribe()`.\n                // If there is registered subscription for the received message,\n                // we used the default `onreceive` method that the client can set.\n                // This is useful for subscriptions that are automatically created\n                // on the browser side (e.g. [RabbitMQ's temporary\n                // queues](http://www.rabbitmq.com/stomp.html)).\n                var subscription = frame.headers.subscription;\n                var onreceive = _this.subscriptions[subscription] || _this.onreceive;\n                if (onreceive) {\n                  // 1.2 define ack header if ack is set to client\n                  // and this header must be used for ack/nack\n                  var messageID = _this.version === VERSIONS.V1_2 && frame.headers.ack || frame.headers['message-id'];\n                  // add `ack()` and `nack()` methods directly to the returned frame\n                  // so that a simple call to `message.ack()` can acknowledge the message.\n                  frame.ack = _this.ack.bind(_this, messageID, subscription);\n                  frame.nack = _this.nack.bind(_this, messageID, subscription);\n                  onreceive(frame);\n                } else {\n                  _this.debug('Unhandled received MESSAGE: ' + frame);\n                }\n                break;\n              // [RECEIPT Frame](http://stomp.github.com/stomp-specification-1.1.html#RECEIPT)\n              //\n              // The client instance can set its `onreceipt` field to a function taking\n              // a frame argument that will be called when a receipt is received from\n              // the server:\n              //\n              //     client.onreceipt = function(frame) {\n              //       receiptID = frame.headers['receipt-id'];\n              //       ...\n              //     }\n              case 'RECEIPT':\n                if (_this.onreceipt) _this.onreceipt(frame);\n                break;\n              // [ERROR Frame](http://stomp.github.com/stomp-specification-1.1.html#ERROR)\n              case 'ERROR':\n                if (errorCallback) errorCallback(frame);\n                break;\n              default:\n                _this.debug('Unhandled frame: ' + frame);\n            }\n          });\n        };\n        this.ws.onclose = function (event) {\n          _this.debug('Whoops! Lost connection to ' + _this.ws.url + ':', {\n            event: event\n          });\n          _this._cleanUp();\n          if (errorCallback) errorCallback(event);\n        };\n        this.ws.onopen = function () {\n          _this.debug('Web Socket Opened...');\n          // 1st protocol fallback on user 1st protocols options\n          // to prevent edge case where server does not comply and respond with a choosen protocol\n          // or when ws client does not handle protocol property very well\n          headers['accept-version'] = getSupportedVersion(_this.ws.protocol || _this.protocols[0], _this.debug.bind(_this));\n          // Check if we already have heart-beat in headers before adding them\n          if (!headers['heart-beat']) {\n            headers['heart-beat'] = [_this.heartbeat.outgoing, _this.heartbeat.incoming].join(',');\n          }\n          _this._transmit('CONNECT', headers);\n        };\n        if (this.ws.readyState === this.ws.OPEN) {\n          this.ws.onopen();\n        }\n      }\n\n      // [DISCONNECT Frame](http://stomp.github.com/stomp-specification-1.1.html#DISCONNECT)\n    }, {\n      key: 'disconnect',\n      value: function disconnect(disconnectCallback) {\n        var headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        this._transmit('DISCONNECT', headers);\n        // Discard the onclose callback to avoid calling the errorCallback when\n        // the client is properly disconnected.\n        this.ws.onclose = null;\n        this.ws.close();\n        this._cleanUp();\n        // TODO: what's the point of this callback disconnect is not async\n        if (disconnectCallback) disconnectCallback();\n      }\n\n      // [SEND Frame](http://stomp.github.com/stomp-specification-1.1.html#SEND)\n      //\n      // * `destination` is MANDATORY.\n    }, {\n      key: 'send',\n      value: function send(destination) {\n        var body = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n        var headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var hdrs = Object.assign({}, headers);\n        hdrs.destination = destination;\n        this._transmit('SEND', hdrs, body);\n      }\n\n      // [BEGIN Frame](http://stomp.github.com/stomp-specification-1.1.html#BEGIN)\n      //\n      // If no transaction ID is passed, one will be created automatically\n    }, {\n      key: 'begin',\n      value: function begin() {\n        var transaction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'tx-' + createId();\n        this._transmit('BEGIN', {\n          transaction: transaction\n        });\n        return {\n          id: transaction,\n          commit: this.commit.bind(this, transaction),\n          abort: this.abort.bind(this, transaction)\n        };\n      }\n\n      // [COMMIT Frame](http://stomp.github.com/stomp-specification-1.1.html#COMMIT)\n      //\n      // * `transaction` is MANDATORY.\n      //\n      // It is preferable to commit a transaction by calling `commit()` directly on\n      // the object returned by `client.begin()`:\n      //\n      //     var tx = client.begin(txid);\n      //     ...\n      //     tx.commit();\n    }, {\n      key: 'commit',\n      value: function commit(transaction) {\n        this._transmit('COMMIT', {\n          transaction: transaction\n        });\n      }\n\n      // [ABORT Frame](http://stomp.github.com/stomp-specification-1.1.html#ABORT)\n      //\n      // * `transaction` is MANDATORY.\n      //\n      // It is preferable to abort a transaction by calling `abort()` directly on\n      // the object returned by `client.begin()`:\n      //\n      //     var tx = client.begin(txid);\n      //     ...\n      //     tx.abort();\n    }, {\n      key: 'abort',\n      value: function abort(transaction) {\n        this._transmit('ABORT', {\n          transaction: transaction\n        });\n      }\n\n      // [ACK Frame](http://stomp.github.com/stomp-specification-1.1.html#ACK)\n      //\n      // * `messageID` & `subscription` are MANDATORY.\n      //\n      // It is preferable to acknowledge a message by calling `ack()` directly\n      // on the message handled by a subscription callback:\n      //\n      //     client.subscribe(destination,\n      //       function(message) {\n      //         // process the message\n      //         // acknowledge it\n      //         message.ack();\n      //       },\n      //       {'ack': 'client'}\n      //     );\n    }, {\n      key: 'ack',\n      value: function ack(messageID, subscription) {\n        var headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var hdrs = Object.assign({}, headers);\n        // 1.2 change id header name from message-id to id\n        var idAttr = this.version === VERSIONS.V1_2 ? 'id' : 'message-id';\n        hdrs[idAttr] = messageID;\n        hdrs.subscription = subscription;\n        this._transmit('ACK', hdrs);\n      }\n\n      // [NACK Frame](http://stomp.github.com/stomp-specification-1.1.html#NACK)\n      //\n      // * `messageID` & `subscription` are MANDATORY.\n      //\n      // It is preferable to nack a message by calling `nack()` directly on the\n      // message handled by a subscription callback:\n      //\n      //     client.subscribe(destination,\n      //       function(message) {\n      //         // process the message\n      //         // an error occurs, nack it\n      //         message.nack();\n      //       },\n      //       {'ack': 'client'}\n      //     );\n    }, {\n      key: 'nack',\n      value: function nack(messageID, subscription) {\n        var headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var hdrs = Object.assign({}, headers);\n        // 1.2 change id header name from message-id to id\n        var idAttr = this.version === VERSIONS.V1_2 ? 'id' : 'message-id';\n        hdrs[idAttr] = messageID;\n        hdrs.subscription = subscription;\n        this._transmit('NACK', hdrs);\n      }\n\n      // [SUBSCRIBE Frame](http://stomp.github.com/stomp-specification-1.1.html#SUBSCRIBE)\n    }, {\n      key: 'subscribe',\n      value: function subscribe(destination, callback) {\n        var headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var hdrs = Object.assign({}, headers);\n        // for convenience if the `id` header is not set, we create a new one for this client\n        // that will be returned to be able to unsubscribe this subscription\n        if (!hdrs.id) hdrs.id = 'sub-' + createId();\n        hdrs.destination = destination;\n        this.subscriptions[hdrs.id] = callback;\n        this._transmit('SUBSCRIBE', hdrs);\n        return {\n          id: hdrs.id,\n          unsubscribe: this.unsubscribe.bind(this, hdrs.id)\n        };\n      }\n\n      // [UNSUBSCRIBE Frame](http://stomp.github.com/stomp-specification-1.1.html#UNSUBSCRIBE)\n      //\n      // * `id` is MANDATORY.\n      //\n      // It is preferable to unsubscribe from a subscription by calling\n      // `unsubscribe()` directly on the object returned by `client.subscribe()`:\n      //\n      //     var subscription = client.subscribe(destination, onmessage);\n      //     ...\n      //     subscription.unsubscribe(headers);\n    }, {\n      key: 'unsubscribe',\n      value: function unsubscribe(id) {\n        var headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var hdrs = Object.assign({}, headers);\n        delete this.subscriptions[id];\n        hdrs.id = id;\n        this._transmit('UNSUBSCRIBE', hdrs);\n      }\n\n      // Clean up client resources when it is disconnected or the server did not\n      // send heart beats in a timely fashion\n    }, {\n      key: '_cleanUp',\n      value: function _cleanUp() {\n        this.connected = false;\n        clearInterval(this.pinger);\n        clearInterval(this.ponger);\n      }\n\n      // Base method to transmit any stomp frame\n    }, {\n      key: '_transmit',\n      value: function _transmit(command, headers, body) {\n        var out = Frame.marshall(command, headers, body);\n        this.debug('>>> ' + out, {\n          frame: {\n            command: command,\n            headers: headers,\n            body: body\n          }\n        });\n        this._wsSend(out);\n      }\n    }, {\n      key: '_wsSend',\n      value: function _wsSend(data) {\n        if (this.isBinary) data = unicodeStringToTypedArray(data);\n        this.debug('>>> length ' + data.length);\n        // if necessary, split the *STOMP* frame to send it on many smaller\n        // *WebSocket* frames\n        while (true) {\n          if (data.length > this.maxWebSocketFrameSize) {\n            this.ws.send(data.slice(0, this.maxWebSocketFrameSize));\n            data = data.slice(this.maxWebSocketFrameSize);\n            this.debug('remaining = ' + data.length);\n          } else {\n            return this.ws.send(data);\n          }\n        }\n      }\n\n      // Heart-beat negotiation\n    }, {\n      key: '_setupHeartbeat',\n      value: function _setupHeartbeat(headers) {\n        var _this2 = this;\n        if (this.version !== VERSIONS.V1_1 && this.version !== VERSIONS.V1_2) return;\n\n        // heart-beat header received from the server looks like:\n        //\n        //     heart-beat: sx, sy\n\n        var _split$map = (headers['heart-beat'] || '0,0').split(',').map(function (v) {\n            return parseInt(v, 10);\n          }),\n          _split$map2 = slicedToArray(_split$map, 2),\n          serverOutgoing = _split$map2[0],\n          serverIncoming = _split$map2[1];\n        if (!(this.heartbeat.outgoing === 0 || serverIncoming === 0)) {\n          var ttl = Math.max(this.heartbeat.outgoing, serverIncoming);\n          this.debug('send PING every ' + ttl + 'ms');\n          this.pinger = setInterval(function () {\n            _this2._wsSend(BYTES.LF);\n            _this2.debug('>>> PING');\n          }, ttl);\n        }\n        if (!(this.heartbeat.incoming === 0 || serverOutgoing === 0)) {\n          var _ttl = Math.max(this.heartbeat.incoming, serverOutgoing);\n          this.debug('check PONG every ' + _ttl + 'ms');\n          this.ponger = setInterval(function () {\n            var delta = Date.now() - _this2.serverActivity;\n            // We wait twice the TTL to be flexible on window's setInterval calls\n            if (delta > _ttl * 2) {\n              _this2.debug('did not receive server activity for the last ' + delta + 'ms');\n              _this2.ws.close();\n            }\n          }, _ttl);\n        }\n      }\n\n      // parse the arguments number and type to find the headers, connectCallback and\n      // (eventually undefined) errorCallback\n    }, {\n      key: '_parseConnect',\n      value: function _parseConnect() {\n        var headers = {},\n          connectCallback = void 0,\n          errorCallback = void 0;\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        switch (args.length) {\n          case 2:\n            headers = args[0];\n            connectCallback = args[1];\n            break;\n          case 3:\n            if (args[1] instanceof Function) {\n              headers = args[0];\n              connectCallback = args[1];\n              errorCallback = args[2];\n            } else {\n              headers.login = args[0];\n              headers.passcode = args[1];\n              connectCallback = args[2];\n            }\n            break;\n          case 4:\n            headers.login = args[0];\n            headers.passcode = args[1];\n            connectCallback = args[2];\n            errorCallback = args[3];\n            break;\n          default:\n            headers.login = args[0];\n            headers.passcode = args[1];\n            connectCallback = args[2];\n            errorCallback = args[3];\n            headers.host = args[4];\n        }\n        return [headers, connectCallback, errorCallback];\n      }\n    }]);\n    return Client;\n  }();\n\n  // The `webstomp` Object\n  var webstomp = {\n    Frame: Frame,\n    VERSIONS: VERSIONS,\n    // This method creates a WebSocket client that is connected to\n    // the STOMP server located at the url.\n    client: function client(url) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var ws = new WebSocket(url, options.protocols || VERSIONS.supportedProtocols());\n      return new Client(ws, options);\n    },\n    // This method is an alternative to `webstomp.client()` to let the user\n    // specify the WebSocket to use (either a standard HTML5 WebSocket or\n    // a similar object).\n    over: function over() {\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return new (Function.prototype.bind.apply(Client, [null].concat(args)))();\n    }\n  };\n  return webstomp;\n});","map":{"version":3,"names":["global","factory","exports","module","define","amd","webstomp","classCallCheck","instance","Constructor","TypeError","createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","slicedToArray","sliceIterator","arr","_arr","_n","_d","_e","undefined","_i","Symbol","iterator","_s","next","done","push","value","err","Array","isArray","toConsumableArray","arr2","from","VERSIONS","V1_0","V1_1","V1_2","supportedVersions","supportedProtocols","PROTOCOLS_VERSIONS","getSupportedVersion","protocol","debug","knownVersion","BYTES","LF","NULL","trim","str","replace","unicodeStringToTypedArray","s","escstr","encodeURIComponent","binstr","match","p1","String","fromCharCode","map","call","c","charCodeAt","Uint8Array","typedArrayToUnicodeString","ua","apply","m","p","code","toString","toUpperCase","decodeURIComponent","sizeOfUTF8","createId","ts","Date","getTime","rand","Math","floor","random","Frame","command","headers","arguments","body","_this","lines","skipContentLength","keys","forEach","name","join","unmarshallSingle","data","divider","search","RegExp","headerLines","substring","split","shift","bodyIndex","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_iterator","reverse","_step","line","idx","indexOf","return","len","parseInt","chr","charAt","unmarshall","datas","frames","firstFrames","slice","lastFrame","r","f","partial","marshall","frame","Client","ws","options","_options$binary","binary","_options$heartbeat","heartbeat","outgoing","incoming","_options$debug","_options$protocols","protocols","binaryType","isBinary","hasDebug","connected","maxWebSocketFrameSize","subscriptions","partialData","_console","console","log","connect","_parseConnect2","_parseConnect","_parseConnect3","connectCallback","errorCallback","onmessage","evt","ArrayBuffer","serverActivity","now","unmarshalledData","server","version","_setupHeartbeat","subscription","onreceive","messageID","ack","bind","nack","onreceipt","onclose","event","url","_cleanUp","onopen","_transmit","readyState","OPEN","disconnect","disconnectCallback","close","send","destination","hdrs","assign","begin","transaction","id","commit","abort","idAttr","subscribe","callback","unsubscribe","clearInterval","pinger","ponger","out","_wsSend","_this2","_split$map","v","_split$map2","serverOutgoing","serverIncoming","ttl","max","setInterval","_ttl","delta","_len","args","_key","Function","login","passcode","host","client","WebSocket","over","concat"],"sources":["C:/CSAI_Front/node_modules/webstomp-client/dist/webstomp.js"],"sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global.webstomp = factory());\n}(this, (function () { 'use strict';\n\n  var classCallCheck = function (instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  };\n\n  var createClass = function () {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    return function (Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) defineProperties(Constructor, staticProps);\n      return Constructor;\n    };\n  }();\n\n  var slicedToArray = function () {\n    function sliceIterator(arr, i) {\n      var _arr = [];\n      var _n = true;\n      var _d = false;\n      var _e = undefined;\n\n      try {\n        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n          _arr.push(_s.value);\n\n          if (i && _arr.length === i) break;\n        }\n      } catch (err) {\n        _d = true;\n        _e = err;\n      } finally {\n        try {\n          if (!_n && _i[\"return\"]) _i[\"return\"]();\n        } finally {\n          if (_d) throw _e;\n        }\n      }\n\n      return _arr;\n    }\n\n    return function (arr, i) {\n      if (Array.isArray(arr)) {\n        return arr;\n      } else if (Symbol.iterator in Object(arr)) {\n        return sliceIterator(arr, i);\n      } else {\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n      }\n    };\n  }();\n\n  var toConsumableArray = function (arr) {\n    if (Array.isArray(arr)) {\n      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n      return arr2;\n    } else {\n      return Array.from(arr);\n    }\n  };\n\n  var VERSIONS = {\n      V1_0: '1.0',\n      V1_1: '1.1',\n      V1_2: '1.2',\n      // Versions of STOMP specifications supported\n      supportedVersions: function supportedVersions() {\n          return '1.2,1.1,1.0';\n      },\n      supportedProtocols: function supportedProtocols() {\n          return ['v10.stomp', 'v11.stomp', 'v12.stomp'];\n      }\n  };\n\n  var PROTOCOLS_VERSIONS = {\n      'v10.stomp': VERSIONS.V1_0,\n      'v11.stomp': VERSIONS.V1_1,\n      'v12.stomp': VERSIONS.V1_2\n  };\n\n  function getSupportedVersion(protocol, debug) {\n      var knownVersion = PROTOCOLS_VERSIONS[protocol];\n      if (!knownVersion && debug) {\n          debug('DEPRECATED: ' + protocol + ' is not a recognized STOMP version. In next major client version, this will close the connection.');\n      }\n      // 2nd temporary fallback if the protocol\n      // does not match a supported STOMP version\n      // This fallback will be removed in next major version\n      return knownVersion || VERSIONS.V1_2;\n  }\n\n  // Define constants for bytes used throughout the code.\n  var BYTES = {\n      // LINEFEED byte (octet 10)\n      LF: '\\x0A',\n      // NULL byte (octet 0)\n      NULL: '\\x00'\n  };\n\n  // utility function to trim any whitespace before and after a string\n  var trim = function trim(str) {\n      return str.replace(/^\\s+|\\s+$/g, '');\n  };\n\n  // from https://coolaj86.com/articles/unicode-string-to-a-utf-8-typed-array-buffer-in-javascript/\n  function unicodeStringToTypedArray(s) {\n      var escstr = encodeURIComponent(s);\n      var binstr = escstr.replace(/%([0-9A-F]{2})/g, function (match, p1) {\n          return String.fromCharCode('0x' + p1);\n      });\n      var arr = Array.prototype.map.call(binstr, function (c) {\n          return c.charCodeAt(0);\n      });\n      return new Uint8Array(arr);\n  }\n\n  // from https://coolaj86.com/articles/unicode-string-to-a-utf-8-typed-array-buffer-in-javascript/\n  function typedArrayToUnicodeString(ua) {\n      var binstr = String.fromCharCode.apply(String, toConsumableArray(ua));\n      var escstr = binstr.replace(/(.)/g, function (m, p) {\n          var code = p.charCodeAt(0).toString(16).toUpperCase();\n          if (code.length < 2) {\n              code = '0' + code;\n          }\n          return '%' + code;\n      });\n      return decodeURIComponent(escstr);\n  }\n\n  // Compute the size of a UTF-8 string by counting its number of bytes\n  // (and not the number of characters composing the string)\n  function sizeOfUTF8(s) {\n      if (!s) return 0;\n      return encodeURIComponent(s).match(/%..|./g).length;\n  }\n\n  function createId() {\n      var ts = new Date().getTime();\n      var rand = Math.floor(Math.random() * 1000);\n      return ts + '-' + rand;\n  }\n\n  // [STOMP Frame](http://stomp.github.com/stomp-specification-1.1.html#STOMP_Frames) Class\n\n  var Frame = function () {\n\n      // Frame constructor\n      function Frame(command) {\n          var headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n          var body = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n          classCallCheck(this, Frame);\n\n          this.command = command;\n          this.headers = headers;\n          this.body = body;\n      }\n\n      // Provides a textual representation of the frame\n      // suitable to be sent to the server\n\n\n      createClass(Frame, [{\n          key: 'toString',\n          value: function toString() {\n              var _this = this;\n\n              var lines = [this.command],\n                  skipContentLength = this.headers['content-length'] === false;\n              if (skipContentLength) delete this.headers['content-length'];\n\n              Object.keys(this.headers).forEach(function (name) {\n                  var value = _this.headers[name];\n                  lines.push(name + ':' + value);\n              });\n\n              if (this.body && !skipContentLength) {\n                  lines.push('content-length:' + sizeOfUTF8(this.body));\n              }\n\n              lines.push(BYTES.LF + this.body);\n\n              return lines.join(BYTES.LF);\n          }\n\n          // Unmarshall a single STOMP frame from a `data` string\n\n      }], [{\n          key: 'unmarshallSingle',\n          value: function unmarshallSingle(data) {\n              // search for 2 consecutives LF byte to split the command\n              // and headers from the body\n              var divider = data.search(new RegExp(BYTES.LF + BYTES.LF)),\n                  headerLines = data.substring(0, divider).split(BYTES.LF),\n                  command = headerLines.shift(),\n                  headers = {},\n                  body = '',\n\n              // skip the 2 LF bytes that divides the headers from the body\n              bodyIndex = divider + 2;\n\n              // Parse headers in reverse order so that for repeated headers, the 1st\n              // value is used\n              var _iteratorNormalCompletion = true;\n              var _didIteratorError = false;\n              var _iteratorError = undefined;\n\n              try {\n                  for (var _iterator = headerLines.reverse()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                      var line = _step.value;\n\n                      var idx = line.indexOf(':');\n                      headers[trim(line.substring(0, idx))] = trim(line.substring(idx + 1));\n                  }\n                  // Parse body\n                  // check for content-length or topping at the first NULL byte found.\n              } catch (err) {\n                  _didIteratorError = true;\n                  _iteratorError = err;\n              } finally {\n                  try {\n                      if (!_iteratorNormalCompletion && _iterator.return) {\n                          _iterator.return();\n                      }\n                  } finally {\n                      if (_didIteratorError) {\n                          throw _iteratorError;\n                      }\n                  }\n              }\n\n              if (headers['content-length']) {\n                  var len = parseInt(headers['content-length'], 10);\n                  body = ('' + data).substring(bodyIndex, bodyIndex + len);\n              } else {\n                  var chr = null;\n                  for (var i = bodyIndex; i < data.length; i++) {\n                      chr = data.charAt(i);\n                      if (chr === BYTES.NULL) break;\n                      body += chr;\n                  }\n              }\n\n              return new Frame(command, headers, body);\n          }\n\n          // Split the data before unmarshalling every single STOMP frame.\n          // Web socket servers can send multiple frames in a single websocket message.\n          // If the message size exceeds the websocket message size, then a single\n          // frame can be fragmented across multiple messages.\n          //\n          // `datas` is a string.\n          //\n          // returns an *array* of Frame objects\n\n      }, {\n          key: 'unmarshall',\n          value: function unmarshall(datas) {\n              // split and unmarshall *multiple STOMP frames* contained in a *single WebSocket frame*.\n              // The data is split when a NULL byte (followed by zero or many LF bytes) is found\n              var frames = datas.split(new RegExp(BYTES.NULL + BYTES.LF + '*')),\n                  firstFrames = frames.slice(0, -1),\n                  lastFrame = frames.slice(-1)[0],\n                  r = {\n                  frames: firstFrames.map(function (f) {\n                      return Frame.unmarshallSingle(f);\n                  }),\n                  partial: ''\n              };\n\n              // If this contains a final full message or just a acknowledgement of a PING\n              // without any other content, process this frame, otherwise return the\n              // contents of the buffer to the caller.\n              if (lastFrame === BYTES.LF || lastFrame.search(RegExp(BYTES.NULL + BYTES.LF + '*$')) !== -1) {\n                  r.frames.push(Frame.unmarshallSingle(lastFrame));\n              } else {\n                  r.partial = lastFrame;\n              }\n\n              return r;\n          }\n\n          // Marshall a Stomp frame\n\n      }, {\n          key: 'marshall',\n          value: function marshall(command, headers, body) {\n              var frame = new Frame(command, headers, body);\n              return frame.toString() + BYTES.NULL;\n          }\n      }]);\n      return Frame;\n  }();\n\n  // STOMP Client Class\n  //\n  // All STOMP protocol is exposed as methods of this class (`connect()`,\n  // `send()`, etc.)\n\n  var Client = function () {\n      function Client(ws) {\n          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n          classCallCheck(this, Client);\n\n          // cannot have default options object + destructuring in the same time in method signature\n          var _options$binary = options.binary,\n              binary = _options$binary === undefined ? false : _options$binary,\n              _options$heartbeat = options.heartbeat,\n              heartbeat = _options$heartbeat === undefined ? { outgoing: 10000, incoming: 10000 } : _options$heartbeat,\n              _options$debug = options.debug,\n              debug = _options$debug === undefined ? true : _options$debug,\n              _options$protocols = options.protocols,\n              protocols = _options$protocols === undefined ? [] : _options$protocols;\n\n\n          this.ws = ws;\n          this.ws.binaryType = 'arraybuffer';\n          this.isBinary = !!binary;\n          this.hasDebug = !!debug;\n          this.connected = false;\n          // Heartbeat properties of the client\n          // outgoing: send heartbeat every 10s by default (value is in ms)\n          // incoming: expect to receive server heartbeat at least every 10s by default\n          // falsy value means no heartbeat hence 0,0\n          this.heartbeat = heartbeat || { outgoing: 0, incoming: 0 };\n          // maximum *WebSocket* frame size sent by the client. If the STOMP frame\n          // is bigger than this value, the STOMP frame will be sent using multiple\n          // WebSocket frames (default is 16KiB)\n          this.maxWebSocketFrameSize = 16 * 1024;\n          // subscription callbacks indexed by subscriber's ID\n          this.subscriptions = {};\n          this.partialData = '';\n          this.protocols = protocols;\n      }\n\n      // //// Debugging\n      //\n      // By default, debug messages are logged in the window's console if it is defined.\n      // This method is called for every actual transmission of the STOMP frames over the\n      // WebSocket.\n      //\n      // It is possible to set a `debug(message, data)` method\n      // on a client instance to handle differently the debug messages:\n      //\n      //     client.debug = function(str) {\n      //         // append the debug log to a #debug div\n      //         $(\"#debug\").append(str + \"\\n\");\n      //     };\n\n\n      createClass(Client, [{\n          key: 'debug',\n          value: function debug() {\n              var _console;\n\n              if (this.hasDebug) (_console = console).log.apply(_console, arguments);\n          }\n\n          // [CONNECT Frame](http://stomp.github.com/stomp-specification-1.1.html#CONNECT_or_STOMP_Frame)\n          //\n          // The `connect` method accepts different number of arguments and types:\n          //\n          // * `connect(headers, connectCallback)`\n          // * `connect(headers, connectCallback, errorCallback)`\n          // * `connect(login, passcode, connectCallback)`\n          // * `connect(login, passcode, connectCallback, errorCallback)`\n          // * `connect(login, passcode, connectCallback, errorCallback, host)`\n          //\n          // The errorCallback is optional and the 2 first forms allow to pass other\n          // headers in addition to `client`, `passcode` and `host`.\n\n      }, {\n          key: 'connect',\n          value: function connect() {\n              var _this = this;\n\n              var _parseConnect2 = this._parseConnect.apply(this, arguments),\n                  _parseConnect3 = slicedToArray(_parseConnect2, 3),\n                  headers = _parseConnect3[0],\n                  connectCallback = _parseConnect3[1],\n                  errorCallback = _parseConnect3[2];\n\n              this.connectCallback = connectCallback;\n              this.debug('Opening Web Socket...');\n              this.ws.onmessage = function (evt) {\n                  var data = evt.data;\n                  if (evt.data instanceof ArrayBuffer) {\n                      data = typedArrayToUnicodeString(new Uint8Array(evt.data));\n                  }\n                  _this.serverActivity = Date.now();\n                  // heartbeat\n                  if (data === BYTES.LF) {\n                      _this.debug('<<< PONG');\n                      return;\n                  }\n                  _this.debug('<<< ' + data);\n                  // Handle STOMP frames received from the server\n                  // The unmarshall function returns the frames parsed and any remaining\n                  // data from partial frames.\n                  var unmarshalledData = Frame.unmarshall(_this.partialData + data);\n                  _this.partialData = unmarshalledData.partial;\n                  unmarshalledData.frames.forEach(function (frame) {\n                      switch (frame.command) {\n                          // [CONNECTED Frame](http://stomp.github.com/stomp-specification-1.1.html#CONNECTED_Frame)\n                          case 'CONNECTED':\n                              _this.debug('connected to server ' + frame.headers.server);\n                              _this.connected = true;\n                              _this.version = frame.headers.version;\n                              _this._setupHeartbeat(frame.headers);\n                              if (connectCallback) connectCallback(frame);\n                              break;\n                          // [MESSAGE Frame](http://stomp.github.com/stomp-specification-1.1.html#MESSAGE)\n                          case 'MESSAGE':\n                              // the `onreceive` callback is registered when the client calls\n                              // `subscribe()`.\n                              // If there is registered subscription for the received message,\n                              // we used the default `onreceive` method that the client can set.\n                              // This is useful for subscriptions that are automatically created\n                              // on the browser side (e.g. [RabbitMQ's temporary\n                              // queues](http://www.rabbitmq.com/stomp.html)).\n                              var subscription = frame.headers.subscription;\n                              var onreceive = _this.subscriptions[subscription] || _this.onreceive;\n                              if (onreceive) {\n                                  // 1.2 define ack header if ack is set to client\n                                  // and this header must be used for ack/nack\n                                  var messageID = _this.version === VERSIONS.V1_2 && frame.headers.ack || frame.headers['message-id'];\n                                  // add `ack()` and `nack()` methods directly to the returned frame\n                                  // so that a simple call to `message.ack()` can acknowledge the message.\n                                  frame.ack = _this.ack.bind(_this, messageID, subscription);\n                                  frame.nack = _this.nack.bind(_this, messageID, subscription);\n                                  onreceive(frame);\n                              } else {\n                                  _this.debug('Unhandled received MESSAGE: ' + frame);\n                              }\n                              break;\n                          // [RECEIPT Frame](http://stomp.github.com/stomp-specification-1.1.html#RECEIPT)\n                          //\n                          // The client instance can set its `onreceipt` field to a function taking\n                          // a frame argument that will be called when a receipt is received from\n                          // the server:\n                          //\n                          //     client.onreceipt = function(frame) {\n                          //       receiptID = frame.headers['receipt-id'];\n                          //       ...\n                          //     }\n                          case 'RECEIPT':\n                              if (_this.onreceipt) _this.onreceipt(frame);\n                              break;\n                          // [ERROR Frame](http://stomp.github.com/stomp-specification-1.1.html#ERROR)\n                          case 'ERROR':\n                              if (errorCallback) errorCallback(frame);\n                              break;\n                          default:\n                              _this.debug('Unhandled frame: ' + frame);\n                      }\n                  });\n              };\n              this.ws.onclose = function (event) {\n                  _this.debug('Whoops! Lost connection to ' + _this.ws.url + ':', { event: event });\n                  _this._cleanUp();\n                  if (errorCallback) errorCallback(event);\n              };\n              this.ws.onopen = function () {\n                  _this.debug('Web Socket Opened...');\n                  // 1st protocol fallback on user 1st protocols options\n                  // to prevent edge case where server does not comply and respond with a choosen protocol\n                  // or when ws client does not handle protocol property very well\n                  headers['accept-version'] = getSupportedVersion(_this.ws.protocol || _this.protocols[0], _this.debug.bind(_this));\n                  // Check if we already have heart-beat in headers before adding them\n                  if (!headers['heart-beat']) {\n                      headers['heart-beat'] = [_this.heartbeat.outgoing, _this.heartbeat.incoming].join(',');\n                  }\n                  _this._transmit('CONNECT', headers);\n              };\n              if (this.ws.readyState === this.ws.OPEN) {\n                  this.ws.onopen();\n              }\n          }\n\n          // [DISCONNECT Frame](http://stomp.github.com/stomp-specification-1.1.html#DISCONNECT)\n\n      }, {\n          key: 'disconnect',\n          value: function disconnect(disconnectCallback) {\n              var headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n              this._transmit('DISCONNECT', headers);\n              // Discard the onclose callback to avoid calling the errorCallback when\n              // the client is properly disconnected.\n              this.ws.onclose = null;\n              this.ws.close();\n              this._cleanUp();\n              // TODO: what's the point of this callback disconnect is not async\n              if (disconnectCallback) disconnectCallback();\n          }\n\n          // [SEND Frame](http://stomp.github.com/stomp-specification-1.1.html#SEND)\n          //\n          // * `destination` is MANDATORY.\n\n      }, {\n          key: 'send',\n          value: function send(destination) {\n              var body = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n              var headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n              var hdrs = Object.assign({}, headers);\n              hdrs.destination = destination;\n              this._transmit('SEND', hdrs, body);\n          }\n\n          // [BEGIN Frame](http://stomp.github.com/stomp-specification-1.1.html#BEGIN)\n          //\n          // If no transaction ID is passed, one will be created automatically\n\n      }, {\n          key: 'begin',\n          value: function begin() {\n              var transaction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'tx-' + createId();\n\n              this._transmit('BEGIN', { transaction: transaction });\n              return {\n                  id: transaction,\n                  commit: this.commit.bind(this, transaction),\n                  abort: this.abort.bind(this, transaction)\n              };\n          }\n\n          // [COMMIT Frame](http://stomp.github.com/stomp-specification-1.1.html#COMMIT)\n          //\n          // * `transaction` is MANDATORY.\n          //\n          // It is preferable to commit a transaction by calling `commit()` directly on\n          // the object returned by `client.begin()`:\n          //\n          //     var tx = client.begin(txid);\n          //     ...\n          //     tx.commit();\n\n      }, {\n          key: 'commit',\n          value: function commit(transaction) {\n              this._transmit('COMMIT', { transaction: transaction });\n          }\n\n          // [ABORT Frame](http://stomp.github.com/stomp-specification-1.1.html#ABORT)\n          //\n          // * `transaction` is MANDATORY.\n          //\n          // It is preferable to abort a transaction by calling `abort()` directly on\n          // the object returned by `client.begin()`:\n          //\n          //     var tx = client.begin(txid);\n          //     ...\n          //     tx.abort();\n\n      }, {\n          key: 'abort',\n          value: function abort(transaction) {\n              this._transmit('ABORT', { transaction: transaction });\n          }\n\n          // [ACK Frame](http://stomp.github.com/stomp-specification-1.1.html#ACK)\n          //\n          // * `messageID` & `subscription` are MANDATORY.\n          //\n          // It is preferable to acknowledge a message by calling `ack()` directly\n          // on the message handled by a subscription callback:\n          //\n          //     client.subscribe(destination,\n          //       function(message) {\n          //         // process the message\n          //         // acknowledge it\n          //         message.ack();\n          //       },\n          //       {'ack': 'client'}\n          //     );\n\n      }, {\n          key: 'ack',\n          value: function ack(messageID, subscription) {\n              var headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n              var hdrs = Object.assign({}, headers);\n              // 1.2 change id header name from message-id to id\n              var idAttr = this.version === VERSIONS.V1_2 ? 'id' : 'message-id';\n              hdrs[idAttr] = messageID;\n              hdrs.subscription = subscription;\n              this._transmit('ACK', hdrs);\n          }\n\n          // [NACK Frame](http://stomp.github.com/stomp-specification-1.1.html#NACK)\n          //\n          // * `messageID` & `subscription` are MANDATORY.\n          //\n          // It is preferable to nack a message by calling `nack()` directly on the\n          // message handled by a subscription callback:\n          //\n          //     client.subscribe(destination,\n          //       function(message) {\n          //         // process the message\n          //         // an error occurs, nack it\n          //         message.nack();\n          //       },\n          //       {'ack': 'client'}\n          //     );\n\n      }, {\n          key: 'nack',\n          value: function nack(messageID, subscription) {\n              var headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n              var hdrs = Object.assign({}, headers);\n              // 1.2 change id header name from message-id to id\n              var idAttr = this.version === VERSIONS.V1_2 ? 'id' : 'message-id';\n              hdrs[idAttr] = messageID;\n              hdrs.subscription = subscription;\n              this._transmit('NACK', hdrs);\n          }\n\n          // [SUBSCRIBE Frame](http://stomp.github.com/stomp-specification-1.1.html#SUBSCRIBE)\n\n      }, {\n          key: 'subscribe',\n          value: function subscribe(destination, callback) {\n              var headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n              var hdrs = Object.assign({}, headers);\n              // for convenience if the `id` header is not set, we create a new one for this client\n              // that will be returned to be able to unsubscribe this subscription\n              if (!hdrs.id) hdrs.id = 'sub-' + createId();\n              hdrs.destination = destination;\n              this.subscriptions[hdrs.id] = callback;\n              this._transmit('SUBSCRIBE', hdrs);\n              return {\n                  id: hdrs.id,\n                  unsubscribe: this.unsubscribe.bind(this, hdrs.id)\n              };\n          }\n\n          // [UNSUBSCRIBE Frame](http://stomp.github.com/stomp-specification-1.1.html#UNSUBSCRIBE)\n          //\n          // * `id` is MANDATORY.\n          //\n          // It is preferable to unsubscribe from a subscription by calling\n          // `unsubscribe()` directly on the object returned by `client.subscribe()`:\n          //\n          //     var subscription = client.subscribe(destination, onmessage);\n          //     ...\n          //     subscription.unsubscribe(headers);\n\n      }, {\n          key: 'unsubscribe',\n          value: function unsubscribe(id) {\n              var headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n              var hdrs = Object.assign({}, headers);\n              delete this.subscriptions[id];\n              hdrs.id = id;\n              this._transmit('UNSUBSCRIBE', hdrs);\n          }\n\n          // Clean up client resources when it is disconnected or the server did not\n          // send heart beats in a timely fashion\n\n      }, {\n          key: '_cleanUp',\n          value: function _cleanUp() {\n              this.connected = false;\n              clearInterval(this.pinger);\n              clearInterval(this.ponger);\n          }\n\n          // Base method to transmit any stomp frame\n\n      }, {\n          key: '_transmit',\n          value: function _transmit(command, headers, body) {\n              var out = Frame.marshall(command, headers, body);\n              this.debug('>>> ' + out, { frame: { command: command, headers: headers, body: body } });\n              this._wsSend(out);\n          }\n      }, {\n          key: '_wsSend',\n          value: function _wsSend(data) {\n              if (this.isBinary) data = unicodeStringToTypedArray(data);\n              this.debug('>>> length ' + data.length);\n              // if necessary, split the *STOMP* frame to send it on many smaller\n              // *WebSocket* frames\n              while (true) {\n                  if (data.length > this.maxWebSocketFrameSize) {\n                      this.ws.send(data.slice(0, this.maxWebSocketFrameSize));\n                      data = data.slice(this.maxWebSocketFrameSize);\n                      this.debug('remaining = ' + data.length);\n                  } else {\n                      return this.ws.send(data);\n                  }\n              }\n          }\n\n          // Heart-beat negotiation\n\n      }, {\n          key: '_setupHeartbeat',\n          value: function _setupHeartbeat(headers) {\n              var _this2 = this;\n\n              if (this.version !== VERSIONS.V1_1 && this.version !== VERSIONS.V1_2) return;\n\n              // heart-beat header received from the server looks like:\n              //\n              //     heart-beat: sx, sy\n\n              var _split$map = (headers['heart-beat'] || '0,0').split(',').map(function (v) {\n                  return parseInt(v, 10);\n              }),\n                  _split$map2 = slicedToArray(_split$map, 2),\n                  serverOutgoing = _split$map2[0],\n                  serverIncoming = _split$map2[1];\n\n              if (!(this.heartbeat.outgoing === 0 || serverIncoming === 0)) {\n                  var ttl = Math.max(this.heartbeat.outgoing, serverIncoming);\n                  this.debug('send PING every ' + ttl + 'ms');\n                  this.pinger = setInterval(function () {\n                      _this2._wsSend(BYTES.LF);\n                      _this2.debug('>>> PING');\n                  }, ttl);\n              }\n\n              if (!(this.heartbeat.incoming === 0 || serverOutgoing === 0)) {\n                  var _ttl = Math.max(this.heartbeat.incoming, serverOutgoing);\n                  this.debug('check PONG every ' + _ttl + 'ms');\n                  this.ponger = setInterval(function () {\n                      var delta = Date.now() - _this2.serverActivity;\n                      // We wait twice the TTL to be flexible on window's setInterval calls\n                      if (delta > _ttl * 2) {\n                          _this2.debug('did not receive server activity for the last ' + delta + 'ms');\n                          _this2.ws.close();\n                      }\n                  }, _ttl);\n              }\n          }\n\n          // parse the arguments number and type to find the headers, connectCallback and\n          // (eventually undefined) errorCallback\n\n      }, {\n          key: '_parseConnect',\n          value: function _parseConnect() {\n              var headers = {},\n                  connectCallback = void 0,\n                  errorCallback = void 0;\n\n              for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n                  args[_key] = arguments[_key];\n              }\n\n              switch (args.length) {\n                  case 2:\n                      headers = args[0];\n                      connectCallback = args[1];\n\n                      break;\n                  case 3:\n                      if (args[1] instanceof Function) {\n                          headers = args[0];\n                          connectCallback = args[1];\n                          errorCallback = args[2];\n                      } else {\n                          headers.login = args[0];\n                          headers.passcode = args[1];\n                          connectCallback = args[2];\n                      }\n                      break;\n                  case 4:\n                      headers.login = args[0];\n                      headers.passcode = args[1];\n                      connectCallback = args[2];\n                      errorCallback = args[3];\n\n                      break;\n                  default:\n                      headers.login = args[0];\n                      headers.passcode = args[1];\n                      connectCallback = args[2];\n                      errorCallback = args[3];\n                      headers.host = args[4];\n\n              }\n\n              return [headers, connectCallback, errorCallback];\n          }\n      }]);\n      return Client;\n  }();\n\n  // The `webstomp` Object\n  var webstomp = {\n      Frame: Frame,\n      VERSIONS: VERSIONS,\n      // This method creates a WebSocket client that is connected to\n      // the STOMP server located at the url.\n      client: function client(url) {\n          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n          var ws = new WebSocket(url, options.protocols || VERSIONS.supportedProtocols());\n          return new Client(ws, options);\n      },\n\n      // This method is an alternative to `webstomp.client()` to let the user\n      // specify the WebSocket to use (either a standard HTML5 WebSocket or\n      // a similar object).\n      over: function over() {\n          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n              args[_key] = arguments[_key];\n          }\n\n          return new (Function.prototype.bind.apply(Client, [null].concat(args)))();\n      }\n  };\n\n  return webstomp;\n\n})));\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}